@Library('iac-devops-lib') _

/*
  Import de libreria compartida en Jenkins:
  1) Manage Jenkins -> System -> Global Trusted Pipeline Libraries.
  2) Name: iac-devops-lib
  3) Default version: feat/base (o la rama que corresponda).
  4) Retrieval method: Modern SCM -> Git
     URL: https://github.com/contreras-adr/devops-training-iac-devops.git
  5) Library Path:
     - `groovy` si usas `groovy/vars/devopsLib.groovy`
*/

pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    booleanParam(name: 'RUN_CD', defaultValue: false, description: 'Ejecutar CD')
    booleanParam(name: 'ENABLE_REGISTRY_PUSH', defaultValue: false, description: 'Publicar imagen en local-registry')
  }

  environment {
    IMAGE_REPO = 'contrerasadr/devops-training-python-app'
    APP_URL = 'http://localhost:5001/'
    COMPOSE_FILE = 'docker-compose.yml'
    COMPOSE_SERVICE = 'app'
    REGISTRY = 'local-registry:5000'
    REGISTRY_REPO = 'contrerasadr/devops-training-python-app'
    REGISTRY_CREDS_ID = 'local-registry-creds'
  }

  stages {
    stage('Info') {
      steps {
        echo "Job: ${env.JOB_NAME}"
        echo "Build: ${env.BUILD_NUMBER}"
        echo "Branch: ${env.BRANCH_NAME}"
      }
    }

    stage('Init - Versionado') {
      steps {
        script {
          env.IMAGE_VERSION = devopsLib.readVersion('VERSION')
          env.IMAGE_NAME = "${env.IMAGE_REPO}:${env.IMAGE_VERSION}"
          echo "Imagen seleccionada: ${env.IMAGE_NAME}"
        }
      }
    }

    stage('CI - Test') {
      steps {
        script {
          devopsLib.runInDocker('python:3.6-slim') {
            sh 'python --version'
            sh 'pip install -r requirements.txt'
            sh 'pytest -q'
          }
        }
      }
    }

    stage('CI - Build image') {
      steps {
        script {
          docker.build(env.IMAGE_NAME, '-f devops/Dockerfile .')
        }
      }
    }

    stage('CI - Push image (opcional)') {
      when {
        expression { return params.ENABLE_REGISTRY_PUSH }
      }
      steps {
        script {
          String registryImage = "${env.REGISTRY}/${env.REGISTRY_REPO}:${env.IMAGE_VERSION}"
          withCredentials([usernamePassword(
            credentialsId: env.REGISTRY_CREDS_ID,
            usernameVariable: 'REG_USER',
            passwordVariable: 'REG_PASS'
          )]) {
            sh """
              echo "\$REG_PASS" | docker login ${env.REGISTRY} -u "\$REG_USER" --password-stdin
              docker tag ${env.IMAGE_NAME} ${registryImage}
              docker push ${registryImage}
            """
          }
        }
      }
    }

    stage('CD') {
      when {
        anyOf {
          expression { return params.RUN_CD }
          branch 'develop'
          branch 'master'
        }
      }
      steps {
        script {
          env.DEPLOY_ENV = (env.BRANCH_NAME == 'master') ? 'PRO' : 'DEV'
          env.COMPOSE_PROJECT = env.DEPLOY_ENV.toLowerCase()
          echo "Deploying to ${env.DEPLOY_ENV}"

          devopsLib.setComposeServiceImage(
            composeFile: env.COMPOSE_FILE,
            serviceName: env.COMPOSE_SERVICE,
            image: env.IMAGE_NAME
          )

          devopsLib.composeUpTestDown(
            up: "docker compose -p ${env.COMPOSE_PROJECT} up -d",
            test: "sleep 10 && docker compose logs app && curl -fsS ${env.APP_URL}",
            down: "docker compose -p ${env.COMPOSE_PROJECT} down --volumes"
          )
        }
      }
      post {
        always {
          sh "docker rmi ${env.IMAGE_NAME} || true"
        }
        success {
          echo 'SUCCESS'
        }
        failure {
          echo 'FAILURE'
          sh "docker compose -p ${env.COMPOSE_PROJECT} logs || true"
        }
      }
    }
  }
}
